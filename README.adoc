= Bitcoin & Blockchain, 'Splain'd
:toc:
:toc-placement!:
:toclevels: 2

_View on http://bluegraybox.github.io/BTCSplain/[GitHub Pages]_

toc::[]

I've been to a number of talks about Bitcoin and Blockchain recently, and I've found them kinda frustrating.
They're given by enthusiasts who go on about all the cool things you'll be able to do with these technologies, without explaining how they work.
I understand not wanting to get too deep in the weeds for a general audience, but without a basic grasp of how these technologies work, people can't trust them.
That's a problem because the entire point of Bitcoin is to replace trust in institutions - government and banks - with trust in technology.
If you don't understand the technology, you're trusting the people selling the technology.
And you should always be skeptical around people trying to sell you something.
That goes double when they're claiming to solve a long-standing human problem.

And I'll tell you now that Bitcoin and Blockchain are not magical, perfect, and flawless.
They have problems - some straightforwardly technical and probably solvable, but some at that tricky and unavoidable intersection of people and technology.

I'm going to use words like "never", "impossible", and "cannot" a number of times in this essay.
You should imagine that they always have a little asterisk next to them referring you to a footnote with a long-winded caveat about breakthroughs in fundamental mathematical theory, advances in quantum computing, or mistakes in software implementations.

I'm not going to go all that deep, but I want to strip away at least one layer of magic.
Bitcoin builds on a few well-understood cryptographic technologies.
While Bitcoin combines and uses them in new ways, these are the same tools you use every time you go to a secure web site.
They have survived decades of scrutiny.
I trust them.

There are only two fundamental tools, and everything else builds on them.
They are public key cryptography, and hash functions.
They're based on some really complicated math, stuff that's way over my head.
The good news is that you don't have to understand the math, just what they do.

== Public Key Cryptography

In the oldest, simplest forms of cryptography, you take a message and replace each letter in it with a different letter according to some secret formula.
The classic one is called Rot-13, where you just "rotate" each letter of the alphabet by 13, so "a" becomes "n", "b" becomes "o", and so on.
To decrypt the message, you just rotate each letter back by 13.
In short:

****
message -> math! -> encrypted message
****

Modern encryption is way more sophisticated, but fundamentally it's still:

****
data -> math! -> encrypted data
****

One thing that's been added is the concept of "keys":

****
data -> math(key)! -> encrypted data
****

Here the math part doesn't have to be secret (and the more public scrutiny it gets, the more trustworthy it is).
What's secret is the key.
Normally (in what we'll now call "symmetric key cryptography") you use the same key for encrypting and decrypting:

****
data -> math(key)! -> encrypted data -> math(key)! -> data
****

The tricky thing with this scheme is getting the key safely to someone else that you want to be able to decrypt your message.

In public key cryptography, there are two keys.
You can use either key to encrypt, but anything you encrypt with one can only be decrypted with the other:

****
data -> math(keyA)! -> encrypted data -> math(*keyB*)! -> data +
data -> math(keyA)! -> encrypted data -> math(*keyA*)! -> garbage
****

One of them is private, one is public.
The private key, you have to keep safe and secret. Really, really safe.
The public key, you give out to anyone. Publish it.

You can send someone a secret message by encrypting it with their public key.
As long as only they have their private key, only they can decrypt it.
Two points that we'll come back to later: If they lose their private key, they can't decrypt it; and anyone who steals their private key can decrypt it.

The other thing you can do is encrypt a message with your private key.
Anyone can decrypt it with your public key, so it's not a secret, but they know that you encrypted it.

We can do both of these in combination.
If I encrypt something with my private key and your public key, only you can read it, and you know it came from me.

How you deal with keys being stolen is a whole topic on its own. We'll skip that for now.

== Cryptographic Hash Functions

A hash function is math that takes in data and spits out a single number:

****
data -> math! -> number
****

The data can be anything from a single letter to a high-def movie file.
The important thing here is that the same input data always generates the same number.

*Cryptographic* hash functions use really sophisticated math to guarantee that this is a one-way street.
You can't figure out what the original data was based on the number.
If you have some data, you can run it through the hash function and see if you get the same number, but that's all.
If you modify the data, you'll get a completely different random number.
(It's not technically "random" because the same input data always produces the same number, but it's what non-mathematicians think of as random.)
There's no way to modify the data and get the same number, or find another set of data that generates the same number.

It may help to know that when we say "number", we're talking a really big number.
The hash function used by Bitcoin produces a 256 bit number, so between 0 and about 10^77. That's getting into the "number of atoms in the universe" range.
So where I said, "you can't", I mean it's like trying to guess a random number in that range.

== Digital Signatures

As mentioned, I could encrypt a document with my private key, and anyone could decrypt it and verify that it came from me.
But a better option is to run the document through a hash function, then just encrypt the resulting number with your private key. That's a digital signature.
The document is readable, but anyone can easily verify the signature by decrypting it with your public key, hashing the document, and comparing the two.

== Bitcoin Transactions

== Blockchain

== Proof of Work

